%----------------------------------------------------------------------------
\chapter{A Linux rendszer}
%----------------------------------------------------------------------------

Az előző fejezetek során bemutatásra került a robot mechanikus modellje,
moduljai, azok feladata, célja, és megvalósítása. Részletesen elemeztem a
firmware fejlesztését, feladatát és kialakítását is. Ebben a feladatban a robot
központi vezérlésére használt Raspberry Pi mikroszámítógépen futó
operációsrendszer és szoftveres környezet felépítéséről és kialakításáról írok
bővebben.

\medskip

A robot magasabb szintű vezérlése erőforrásigényes feladat, kialakításához egy
nagy teljesítményű processzoros rendszerre van szükség.  A nagyobb számítási
kapacitású rendszerekhez és szoftveres megoldásokhoz azonban összetettebb
operációs rendszerre van szükség, ami az erőforrások menedzselését hatékonyan
tudja végezni, és biztosít egy olyan platformot amin a rendszer kezelése, és
magas szintű nyelven írt programok futtatása ergonómikus és hatékony környezetben
tehető meg.

Beágyazott környezetben a leggyakrabban előforduló magas szintű operációsrendszer
a Linux. Ezt a népszerűséget többek között ingyenes, open source modelljének,
lelkes közösségének és flexibilis, kis erőforrásigényű kialakításának köszönheti.
A GNU/Linux mérnöki körökben elterjedt választás asztali felhasználásban is. A
Linux kifejezés önmagában csak a kernelre utal, az operációsrendszer magjára,
amely a feladatütemezésért, és taskmanagementért felel. Egy teljes rendszer
magában foglalja a GNU/Linux kernelt, shell és init programot, és egyéb, a
feladat által meghatározott szükséges könyvtárat, scriptet és binárist. A teljes
rendszercsomagot, amely egy feladatot teljeskörűen ellátni képes disztribúciónak
nevezzük.

\medskip

A Linux rendszer open source kialakításából következik, hogy a célplatformra
(megfelelő támogatás megléte mellett) forráskódból lefordítható. A fordítás
feladata azonban nem triviális feladat, amely manuálisan nagy erőfeszítéseket
igényel, valamint nagy hibakockázattal jár. A feladat mértékét csak növeli, hogy
minden a célplatformon használni kívánt szoftvert és könyvtárat szintén le kell
fordítani és a rendszerrel együtt csomagolni. A disztribúciókészítés fáradtságos
feladatát buildrendszerek alkalmazásával igyekszünk könnyíteni. Ezek a rendszerek
általánosságában a folyamatot scriptek segítségével automatizálják amely két
fontos előnnyel jár. Egyfelől a disztribúciókészítés a script vagy scriptek
konfigurálásával könnyen befolyásolhatóvá, a build folyamat pedig
reprodukálhatóvá válik. Másfelől elosztott fejlesztést tesz lehetővé, az egyes
komponensekhez tartozó build scripteket külön fejlesztők vagy fejlesztőcsoportok
tarthatják karban, így a fordítószkriptek és csomagok karbantartása elosztott
feladattá válik amely egy közösségen (ideális esetben) egyenletesen el tud
oszlani. 

\medskip

A fejezet első részében bemutatom az operációsrendszer működését, és
komponenseit. Kifejtem a bootolás folyamatát, szükséges programokat és
konfigurációkat. Röviden összefoglalom a rendszerben szükségszerű programok
funkcióját, feladatát és felhasználását.

A fejezet második részében a disztribúció elkészítéséhez használt eszköz, a
Yocto Project működését mutatom be.

A fejezet harmadik és utolsó részében a saját disztribúció tervezését,
kialakítását, fejtem ki. Specifikálom az előállítandó rendszer tulajdonságait és
feladatát. Bemutatom a saját csomagjaimhoz tartozó build
scripteket, és patcheket, és az egyes feladatok eléréséhez végrehajtott
konfigurációs lépéseket. Végeredményben értékelem a kész disztribúciót, és
javaslatokat teszek annak fejlesztésére.

%% \section{A Linux}

%% A Linux napjaink legelterjedtebb iparban használt operációsrendszere,
%% megtalálhatjuk minden nagyobb teljesítményt igénylő informatikai eszközünkben. A
%% routerek és networkswitchek szinte kizárólagosan Linux rendszert futtatnak, de
%% megjelenik kisebb beágyazott eszközöktől elkezdve a szervereken keresztül egészen
%% a szuperszámítógépekig egyaránt.

%% A mobiltelefonok platformján legnépszerűbb operációsrendszer, az Android szintén
%% is Linux alapú. Napjainkban az asztali felhasználása is egyre inkább teret nyer
%% köszönhetően a személyre szabhatóságának, teljesítményének és ingyenességének.

%% \subsection{Eredete}

%% A Linux egy Unix-like operációs rendszer. Eredetileg egy Minix klónként indult
%% amelyet Linus Torvalds Finn származású informatikus kezdett el fejleszteni, hobbi
%% projekt szintjén. A rendszer iránt hatalmas volt a lelkesedés, így 1992-es első
%% kiadásától napjainkig aktív fejlesztés alatt áll. 

%% \medskip

%% A fejlesztésben a Linux projekt körül kialakuló közösség aktívan részt vesz. A
%% projekt népszerűségének egyik nagy oka a nyílt forráskód, amelyet bárki igénye
%% szerint elolvashat, és módosíthat saját felhasználási céljainak megfelelően. A
%% projekt jelenleg a GPLv2 licensz alatt érhető el.\todo{kernel.org hivatkozás}

%% A Linux azonban nem pusztán egy közösségi kezdeményezés amely lelkes fejlesztők
%% hobbiprojektje. Fejlesztésében számos nagyvállalat aktívan vállal szerepet. Az
%% infrastruktúrában betöltött központi szerepe miatt kontribúciók érkeznek számos
%% chipgyártó vállalattól, akik saját termékeik támogatottságát szeretnék
%% biztosítani a Linux kernelben, de a felhőalapú szolgáltatásokat biztosító tech
%% óriások is rendszeresen támogatják a projektet.

%% A Linux az eddig valaha volt legnagyobb szoftveres projekt, amelyen a legtöbb
%% fejlesztő dolgozott. A fejlesztés ilyettén módja az ipar minden résztvevőjének
%% kölcsönösen előnyös, az elosztott fejlesztés pedig széleskörű hibakeresést, és új
%% funkciók gyors implementálását teszi lehetővé.

\section{Az operációs rendszer felépítése}

Egy Linux alapú operációs rendszer több részegységből áll, ezek egymást
elfedő rétegekként, vagy egymásra épülő szintenként képzelhetőek el. A Linux,
pontosabban szólva GNU/Linux önmagában csak a kernelt foglalja magában, egy
teljes rendszer működéséhez azonban több egyéb komponensre is szükség van.

Egy ilyen komponens például egy extra kernel modul, amely a kernel
funkcionalitását hivatott kibővíteni, például valamilyen hardver támogatásának
biztosításával, vagy egy init program ami a rendszer bootolása során elsőként
indított program és a szolgáltatások elindításáért felelős. A rendszer szerves
részei továbbá a file-rendszer, interaktív felhasználás esetén shell, és
szövegszerkesztő, alapvető parancssori alkalmazások (coreutils). Természetesen
extrém esetekben a szerkesztő, parancssori alkalmazások, vagy akár shell nélkül
is futtatható Linux kernel, és általa ütemezett szolgáltatások, azonban a
felhasználási esetek döntő többségében ezeknek a megléte nagyban megkönnyíti,
sőt, lényegében lehetővé teszi a rendszer karbantartását és a hibakeresést, ezért
szinte sosem maradnak ki egy disztribúcióból.

\subsection{Kernel}
 
A kernel feladata, hogy a rendelkezésre álló erőforrásokat elossza a
végrehajtandó feladatok között, valamint platformot adjon ezen feladatok közötti
kommunikációnak. Absztrakciós rétegként működik, amely a futtató hardver és
perifériák, valamint a felhasználói programok között teremt kapcsolatot. A kernel
megléte két szegmensre bontja a Linux rendszert, kernelspace és userspace
szintekre.

\subsubsection{Kernelspace és userspace}

A kernelspace minden olyan kódot futtató egységre értendő, amely a
kernel privilégium szintjén fut, és általában közvetlen interakcióban áll
hardverrel. A kernelspace kód rendkívül érzékeny terület, mert bármilyen hiba a
rendszer teljes összeomlásához vezethet, ezért a kernel módosítása, fejlesztése
komplex feladat, amely hatalmas szakértelmet igényel. A kernelspace kódban ezért
csak a feltétlenül szükséges dolgok vannak implementálva, mint például az
ütemező, az IPC és task szinkronizációs megoldások, valamint a hardver
meghajtásához szükséges driver modulok. 

A userspace tartalmaz minden egyéb komponenst. A userspace fejlesztés rendszerint
sokkal könnyebb feladat, mert az esetleges hibák nem vezetnek a rendszer teljes
összeomlásához így a hibakeresés sokkal könnyebb feladat. A kernel által a
userspace alkalmazások számára biztosított funkciókat az alkalmazások
úgynevezett rendszerhívásokon keresztül érhetik el. Rendszerhívás esetén a
program megszakítja futását, és átadja a vezérlést a kernelnek. A kernel elvégzi
a kért feladatot, majd a vezérlés visszatér a userspace alkalmazáshoz.

\subsubsection{Scheduler}

A kernel alapja egy ütemező, angolul scheduler. Ennek a komponensnek a feladata,
hogy a számítási teljesítményt és a processzor időt elossza a futtatandó taskok
között. Az ütemező a kernel egyik legfontosabb komponense, működésének módja
meghatározza az operációsrendszer teljesítményét adott feladatok elvégzésében.

\medskip

A kernel az ütemezőn keresztül minden task számára saját virtuális processzort és
stacket biztosít. Ez a gyakorlatban azt jelenti, hogy a program futása közben nem
észlel változást az ütemezésből kifolyólag, mer minden kontextusváltás esetén az
aktuális kontextus elmentődik, és az új kontextus kerül betöltése. A változások
azonban a rendszer többi komponensében végbemehetnek, így ha a program a rendszer
többi részével lép interakcióba, az esetleges versenyhelyzetet okozhat. A
versenyhelyzetek feloldására, és a taskok közötti hatékony kommunkikációra a
kernel többféle megoldást is kínál. 

Ilyen eszközök a message queue-k, a shared memory, amelyek üzenetküldésre és
kommunikációra használható eszközök, valamint a mutexek és szemaforok, amelyek a
versenyhelyzet kezelésére, valamint a taskok szinkronizálására alkalmasak.

\subsubsection{Modularitás}

A Linux kernel eredetileg monolitikus kernel, azaz egy lefordított oszthatatlan
program, amelynek módosításához az egész kernel újrafordítására van szükség. Ez a
kialakítás sok szempontból nem optimális hiszen minden új eszköz csatlakoztatása
esetén az eszközhöz tartozó drivert bele kell fordítani a kernelbe, valamint ha
probléma lép fel a kernel egy részében, az az egész rendszert destabilizáljal.

Az említett első probléma áthidalása érdekében a fejlesztés során több módosítást
végeztek a Linux kernelen, és egy moduláris kernelt hoztak létre, amely támogatja
a különböző modulok dinamikus betöltését, és ezáltal a kernel funkcióinak runtime
alatt történő kiegészítését. A modulok betöltésének megvalósításához dinamikus
linkelésre volt szükség. A dinamikus linkelés azt jelenti, hogy a program futás
közben, külső file tartalmát képes saját magához linkelni, a betöltést követően
linkelt modulban megvalósított funkcionalités már elérhető a kernelből.

A modulok egyik nagy felhasználási területe a különböző eszközökhöz használt
driverek dinamikus kezelése. A kernel forrás módosítása nélkül egy modul
lefejlesztésével elérhető, hogy egy hardver támogatva legyen a kernel által.

A modularitás azonban nem oldotta meg a monolitikus kernelek nagy hátulütőjét,
mégpedig a rendszer stabilitását. A monolitikus kialakítás miatt ha instabil
modulok kerülnek betöltésre az az egész kernel számára fatális következményekkel
járhat. Egy rosszul működő modul könnyedén az egész rendszert tönkreteheti, ezért
új modul betöltésénél fokozott elővigyázatosságra van szükség. Szerencsére a
kernel, és a modulokat kezelő alkalmazások fel vannak készítve a modulok egyszeri
betöltésére. Egyszeri betöltés esetén amennyiben a betöltött modul hibát okoz,
akkor a rendszert újraindítva a kernel a modul betöltése nélkül indul így a hiba
esetén a fejlesztésre használt rendszer nem válik használhatatlanná.

\subsection{Init}

A kernel önmagában nem végez célfeladatot, csak a feladatot ellátó programoknak
biztosít platformot. A Linux rendszerben a feladatokat service-ek, azaz háttérben
párhuzamosan futó alkalmazások és alkalmazáscsoportok végzik. Az alkalmazások
futásukban erősen függenek egymástól, ebből a függőségi gráfból pedig fa
rajzolható. A bootfolyamat során a megfelelő service-ek automatikus elindításáért
az init program felel.

\medskip

Az init program egy kitüntetett program, amelyet a kernel argumentumként kap meg,
és elsőként indít el. Egy Linux rendszerben a programok elindítása mindig egy
szülő programból indított ``fork\(\)'' és esetlegesen azt követő ``exec\(\)''
rendszerhívásokkal érhető el, így minden folyamatnak létezik szülőfolyamata. A
fenti szabály alól egyedül az init program kivétel, ennek a programnak a
feladata, hogy konfigurációs scriptek felhasználásával a bootolás során a
szükséges rendszerfolyamatokat megfelelő sorrendben elindítsa.

Több implementációja is ismert, legismertebb és legelterjedtebb verziója a
systemd, amely az asztali célra szánt disztribúciók döntő többségében
megtalálható. Beágyazott alkalmazások esetében gyakran előfordul ezen felül a
SysVinit, ami egy régebbi egyszerűbb init implementáció, szűkebb
funkcionalitással. Ennek ellenére beágyazott környezetben gyakran elegendő
funkcionalitást nyújt.

Az init programokhoz rendszerint scriptek megírásával tudunk bootkonfigurációt
létrehozni. Egy konfigurációban meghatározott sorrendben indulnak el a defíniált
folyamatok. A bootolást követően az init program feladata a háttérben futó
programok, szakkifejezéssel daemonok kezelése, amelyhez az init program
parancssori frontendet biztosít. Így lehetőségünk van a rendszer szolgáltatásait
futásidőben is konfigurálni.

\subsection{Shell}

A legtöbb rendszerben kritikus, hogy legyen valamilyen felhasználói bemenet,
amelyet Unix-like rendszerek esetében általában egy shell program biztosít. A
shell egy szöveges parancsértelmező alkalmazás, általános célja, hogy a
renszerhez egy kezelőfelületet biztosítson. A shell rendszerint a rendszerrel
való interaktív kapcsolatbalépés alapvető eszköze. Parancsai alapvető programok,
amelyek a disztribúció részét képezik, és általában a \verb|coreutils| nevű
package részei. Ezekkel a programokkal alapvető file-műveletek és minimális
rendszerkarbantartás végezhető.

A shell programok rendszerint biztosítanak scriptelési lehetőséget is. A
shellscriptek a rendszer alapvető elemei, felhasználásukra számtalan helyen
találhatunk példát. Bonyolultabb programok, vagy programcsoportok elindítására,
vagy ismétlődő feladatok automatizálására shellscript készítése bevett és
praktikus megoldás.

Különböző shell implementációk léteznek, beágyazott környezetben a leggyakrabban
a bash, és dash shellekkel találkozhatunk. Asztali környezetben számos egyéb
shell típus létezik, például zsh, ksh, és a fish.

\subsection{GUI}

A shell interfészen kívül a Linux operációs rendszerek képesek grafikus
felhasználói felületet is biztosítani. Grafikus felületre beágyazott környezetben
nem minden esetben van igény, az esetek jelentős részében a feladat ellátására
egy shell teljesen megfelelő. Akadnak azonban feladatok, ahol a grafikus
megjelenítés része a feladatkörnek, vagy a rendszer karbantartásában jelenthet
segítséget egy grafikus környezet.

\medskip

A Linux rendszereken grafikus megjelenítésre két fő protokollt, az X11 és Wayland
protokollokat szokás alkalmazni.

A két megoldás közül az X11 (vagy röviden csak X) a régebbi rendszer, fejlesztése
napjainkban nagyon lassan halad. Gyakran fogalmazódik meg kritika az elavúlt
technológia miatt, ennek ellenére az X a gyakrabban használt megoldás.
Kialakítása szerver-kliens kapcsolat alapú.  A program elfedi a ki és bemeneti
perifériákat, mint egér billentyűzet és monitor, és ezek eléréséhez interfészt
biztosít az alkalmazások számára.  Kialakításának jellegzetessére a régi
számítástechnikai rendszerek maradványa, amely szerint egy központi számítógéphez
több végpont csatlakozik, a megjelenítést a végpontok végzik, míg a
számításigényes feladat a központi rendszeren fut. Ez a megközelítés napjainkban
kevésbé praktikus, a számítógépek elterjedésének köszönhetően.

A wayland egy modernebb, korszerűbb protokol és architektúra, amely a grafikus
alkalmazások megjelenítésére lett kifejlesztve. Koncepcióját tekintve egyszerűbb
és kisebb az erőforrásigénye. Központi komponense egy úgynevezett wayland
compositor, amelyet minden grafikus környezet saját maga implementálhat. A
wayland biztosít egy nyelvet amin keresztül ezzel a compositor-ral
kommunikálhatnak alkalmazásaink.

\section{A boot folyamat}

A kisebb komplexitású, mikrokontrollereken használt operációs rendszerekkel
ellentétben egy Linux alapú rendszer boot folyamata komplexebb, és több időt is
vesz igénybe. A boot folyamatot fázisokra bonthatjuk, amelyek időben egymást
követik, és mindegyik fázis az időben utána következőt készíti elő, egészen a
teljes rendszer felállásáig.

\subsection{BIOS}

A bekapcsolást követően az alaplapba égetett firmware azaz a
BIOS\footnote{BIOS:~Basic Input Output System} indul el. Ennek a rövid programnak
a feladata a POST azaz Power On Self Test öntesztelő eljárás végrehajtása, majd a
megfelelő bootloader betöltése az MBR szerint. Az MBR azaz Master Boot Record az
első szektorban található kis terület amely tartalmazza a bootloader
információit, valamint a partíciós táblát. Ezek alapján a BIOS elindítja a
megfelelő bootloadert.

\subsection{Bootloader}

A bootloader egy kicsi és kompakt program ami az operációs rendszer komplex
indítását hivatott elősegíteni. Képes akár több kernel imaget is kezelni, és fő
feladata a kernel image betöltése a memóriába. Asztali környezetben, X86
architektúrán leggyakrabban a GRUB2\footnote{GRUB:~Grand Unified BootLoader} nevű
bootloaderrel találkozhatunk. A programot rendszerint csak GRUB-nak nevezik,
lévén teljesen leváltotta az első verziót.

Beágyazott környezetben gyakran az U-Boot\footnote{U-Boot:~Universal Boot}
szolgál a kernel betöltésére. Az U-Boot egy teljesértékű bootloader, amely a
teljes bootfolyamatért felel, ellentétben a GRUB-bal, amely csak úgynevezett
``second stage'' bootloader. U-Boot ARM architektúrájú rendszereken jellemző.

\subsection{Kernel}

A bootloader által betöltött program az operációsrendszer magja, a
kernel. Betöltés után egy bootoláshoz használt előre tömörített speciális
fájlrendszert, az initramfs-t betölti a memóriába ami biztosítja a kernel számára
a megfelelő eszközöket a rendszer elindításához. A következő lépésben a kernel
további hardver inicializációkat hajt végre majd felcsatolja a root
fájlrendszert. Végül utolsó lépésben elindítja az init programot amelyel a
bootolás a userspace-ben folytatódik.

\subsection{Init}

Az init program a processek között egyedülálló módon a 0 process id-val
rendelkezik, és gyökérpontja a processtree-nek. Az init program ezt követően az
init scriptekben meghatározott módon elindítja a rendszerfolyamatokat, és a
rendszer megkezdi működését.

\section{Build}

A Linux operációs rendszer egyik legnagyobb előnye, hogy az egész rendszer
forráskódjához szabad hozzáférésünk van, módosítható és fordítható. Fordítása
azonban összetett és bonyolult feladat, amelynek automatizálására több
keretrendszer is épült. Ezek a keretrendszerek általában megkönnyítik a fordítás
folyamatát, konfigurációs interfészt biztosítanak a kernelhez, illetve adnak
olyan eszközöket, amelyek segítségével a végső image könnyedén elkészíthető. Az
iparban két fontos rendszer terjedt el: a Buildroot, valamint a Yocto Project.

\medskip

A Buildroot egy Makefile és patch gyűjtemény amely segít a forráskód
lefordításában, valamint a root fájrendszer generálásában. A konfigurációban
többek között a menuconfig, és kconfig TUI\footnote{TUI:~Terminal User Interface}
programok biztosítanak felhasználóbarát felületet. 

Általános vélekedés szerint a Buildroot könnyebben tanulható, egyszerűbb
konstrukció. A build rendszer Makefile alapú, ami széles körben ismert a
fejlesztői körökben, így egyszerű módosítások elvégzése könnyebb feladat lehet. A
Buildroothoz azonban sokkal kevesebb cég biztosít supportot, a projektet
jellemzően a közösség tartja karban.

\medskip

A Yocto Project egy umbrella project, amely az openembedded build systemet, és
hozzá tartozó általános receptcsomagokat foglalja össze, és biztosít egy
referencia disztribúciót, amelyet poky-nak nevez. A projekt konfigurációja
scripteken keresztül történik, amely szkriptek használnak Python és shellscript
részleteket, valamint az openembedded build engine, a bitbake saját script
szintaxisában megírt scripteket.

A projekt első számú nagy előnye a széleskörű támogatottság. A Buildroottal
ellentétben a legtöbb gyártó biztosít Yocto támogatást saját termékeihez. A
projektet a Linux Foundation is támogatja, ezek fényében a projekt aktívan és
dinamikusan fejlődik. 

A rendszer sajátossága a buldscriptek, a Yocto terminológia szerint receptek,
rétegekbe szervezése, amely így átlátható rendszerbe foglalja ezeket. A
kialakítás rendkívül flexibillisé teszi a konfigurációt.

A build során a projekt shared state chache-t használ, amelynek köszönhetően a
build folyamat az első build alkalmával lassú, (lassabb mint a Buildroot)
ellenben a további buildek, esetleges konfigurációk módosítása esetén már sokkal
gyorsabban futnak le, így a hibajavítások, és új funkciók implementálása által
igényelt idő sokkal kevesebb, mert nem kell minden változtatás után az egész
fordítást újra elvégezni.  

A projekt hátránya, hogy a kialakításából adódóan sok időt vesz igénybe amíg a
fejlesztő megérti és átlátja a build folyamatot. A konfigurációhoz használt
szintaxis szintén új megtanulandó elem, így a projekt tanulási görbéje
kivételesen meredeknek mondható.

\medskip

A projekt során nagyobb komplexitása ellenére a Yocto projectet választottam,
amely szabadabb fejlesztést és személyre szabhatóságot tesz lehetővé.

\subsection{A Yocto Project felépítése és működése}

A Yocto project komplex és robosztus build rendszer, működésének megértése
kritikus a hatékony munkavégzéshez. A projekt egyik nagy előnye az átfogó és
részletes dokumentáció, amelyet a Yocto honlapján\todo{hivatkozás és source}
találunk. A dokumentáció részletes utasításokat ad számunkra a kezdeti
lépésekhez, amelyet követve az első teszt build könnyen megvalósítható.

A project saját terminológiát használ aminek megértése a működés megértését
nagyban segíti. A következő szegmentsben bemutatom a projekt felépítését, és
leggyakrabban használt kifejezéseinek jelentését.

\subsubsection{Bitbake}

A Yocto project nem más, mint egy umbrella project ami több kisebb projektet fog
össze, és egy egészként bocsátja rendelkezésre. A legfontosabb komponense az
openembedded build system, ami egy komplex projekt build folyamatok
automatizálásához. Az openembedded projekt központjában a Bitbake program áll,
ami egy úgynevezett ``task execution engine'', amely scriptekben defíniált
feladatok végrehajtására lett tervezve.

\medskip

A Bitbake saját script nyelvel rendelkezik, amely szintaxisában hasonlít a
bashscript és Python nyelvekhez. A hasonlóság odáig terjed, hogy a scriptek
magjában teljes Python vagy bash nyelvű függvények találhatóak. A Bitbake
scriptekre használt általános kifejezés a recept, a receptek pedig általánosan
``.bb'' kiterjesztéssel rendelkeznek.

A script legfontosabb feladata különböző taskok létrehozása, és a működésüket
befolyásoló változók értékének beállítása. A Bitbake ezen scriptekből határozza
meg az elvégzendő feladatok listáját, valamint a feladatok egymás közötti
függőségeit. 

\subsubsection{Recept}

A Bitbake számára végrehajtható script, a recept, amely segítségével csomagok
előállítását végezzük. Az openembedded rendszerben minden csomaghoz és
előállítandó komponenshez tartozik egy recept, amely az előállítás pontos
lépéseit tartalmazza. A meghatározott lépések szigorú sorrendben egymás után
hajtódnak végre:

\begin{itemize}
\item{do\_fetch}
\item{do\_unpack}
\item{do\_patch}
\item{do\_configure}
\item{do\_compile}
\item{do\_install}
\item{do\_package}
\end{itemize}

A fenti lista nem teljes, csak átfogó képet hivatott adni egy átlagos csomag
lefordításának lépéseiről. Első lépésben a forráskód letöltése történik, amelyen
kicsomagolás után patcheket alkalmazunk. Ezután a build konfigurációja,
következik, amit a forráskód lefordítása követ. A kész build artifacteket ezután
egy célkönyvtárba telepítjük, és csomagot készítünk belőlük. 

A Yocto renszerének nagy előnye, hogy a receptek módosíthatóak. A működés során
használt változók kiegészíthetőek, vagy éppen teljesen megváltoztathatóak, de a
végrehajtandó feladatokhoz is be tudunk szúrni kiegészítéseket. A
kiegészítésekre úgynevezett ``.bbappend'' fileok szolgálnak, amelyek a velük
azonos nevű recepthez tartalmaznak kiegészítéseket.

A receptek dinamikus módosíthatósága és kiegészíthetősége a Yocto Projectet
rendkívül flexibilissé teszi.

\medskip

A receptekhez tartozó másik fontos koncepció a gyakran használt kód külön fileban
tárolása, erre a célra a ``.bbclass'' fileok szolgálnak. A bbclass fileok olyan
scripteket, és kódokat tartalmaznak, amelyeket több receptben is újra kívánunk
használni, ezzel elkerülhetjük, hogy a gyakran ismételt kód másolásával, vagy
újra megírásával időt pazaroljunk.

\subsubsection{Layer}

A receptek csoportosítására a Yocto Project terminológiája szerint ``layer''-eket
használunk. A layerek nem mások, mint jól szervezett mapparendszerbe gyűjtött
receptek, amelyek tipikusan egy jól körülhatárolható funkcionalitást
biztosítanak. A build konfigurációban lehetőségünk van megadni a layereket,
amelyekből recepteket használni szeretnénk, valamint ezekhez prioritások
társításával sorrendet meghatározni.

A gyakorlatban a layerek git repositoryk, amelyeket a projekt root könyvtárába
klónozva érhetünk el. Tartalmaznak egy layer konfigurációs állományt, amelyben a
layerhez kapcsolódó információk és beállítások érhetőek el. A konfiguráción kívül
a layerekben mappákba szervezve megtalálhatunk konfigurációs fileokat,
recepteket, bbappend fileokat, és patcheket is. Egy réteget tartalmazó mappát
hagyományosan a ``meta-'' kifejezéssel kezdjük, és a biztosított funkcióval
zárjuk, például: ``meta-python'', a réteg amely Python funkcionalitást biztosító
recepteket tárol. 

A layerek egymásra rétegződése elegáns megoldás, amely jól szervezett elosztott
munkavégzést tesz lehetővé. A gyakorlatban egy projekt általában egy layerben
határozza meg a saját receptjeit, amely így könnyen verziókövethető is. A
layerben lehetőségünk van függőségek defíniálására, ezzel meghatározva a pontos
szükségleteket a saját buildkonfigurációnk számára. 

\subsubsection{Verziók és kiadások}

A Yocto Project egy dinamikusan fejlődő rendszer, amely mind saját működésében,
mind a biztosított package-k verziójában aktívan fejlődik. A dinamikus fejlődés
mellett a projektben kihívást jelent a függőségi gráf betartása a packagek
között, ezért a fejlődést rendszerint verziók kiadásával rendelik
mérföldkövekhez.

A kiadott verziók lehetnek LTS\footnote{LTS:~Long Term Release} vagy standard verziók,
amelyek a verzió támogatásának idejét határozzák meg. Minden layer karbantartó
külön branchen kezeli saját layerének azon verzióját, amely egy támogatott Yocto
release-hez tartozik, így a layerek klónozása után a használni kívánt Yocto
verziót a ``git checkout'' parancsal állíthatjuk be. A layer verziójának a hibák
elkerülésének érdekében meg kell egyezniük a használt Yocto verziójával.

\subsubsection{Poky}

A Yocto Project új projektek kezdéséhez egy referenciadisztribúciót biztosít
amely segítségével a projekt dinamikusan bootstrapelhető. Ez a disztribúció nem
keverendő a Linux rendszerek disztribúcióival, tisztán csak a build rendszer
csomagjáról van szó.

A biztosított referenciadisztribúció neve Poky, amely tartalmaz egy openembedded
rendszert, és kiegészítő layereket, amelyek a legtöbb alapvető és gyakran
használt funkcionalitást biztosítják.

\subsubsection{Build konfigurációk}

A build konfigurációt több összetevő határozza meg. A projekt gyökérkönyvtárában
találunk egy \verb|oe-init-build-env| nevű scriptet, amelyet
source-olva\footnote{Fontos hogy source-oljuk a scriptet, mert a buildfolyamathoz
használt környezetet ez a script állítja be shellünkben, ha futtatni próbáljuk
úgy hibát is jelez!} a projekthez szükséges környezet beállthatjuk, valamint
létrehozhatjuk a buildfolyamatok által használt mappát, ennek alapértelmezett
neve a \verb|build|.

A mappában találunk egy \verb|conf| mappát, amelyben a buildhez használt lokális
konfigurációk kapnak helyet különböző fileokban. Ilyen például \verb|local.conf|
file amelyben például a célarchitektúrát határozhatjuk meg, amelyre a
keresztfordítást végezzük. A mappában találjuk továbbá a \verb|bblayers.conf|
file-t amelyben a felhasznált layereket tudjuk specifikálni, amelyben a Bitbake a
recepteket keresheti.

\medskip

A kívánt eredmény, amelyet végsősoron elő kívánunk állítani, egy image file,
amelyen a teljes rendszer megtalálható. Ezt az image-et adathordozóra másolva,
egy bootolható médiát kapunk, amelyel a céleszköz megkezdheti működését. 

Egy image előállítását egyszerre befolyásolja a lokális konfiguráció, valamint a
receptek által meghatározott build konfiguráció, ezek összességében eredményezik
a rendszer kimenetét. 

\subsubsection{Kezelés}

A Yocto több eszközt is biztosít számunkra, amelyel a fejlesztés során felmerülő
feladatokat meg tudjuk oldani. Ezek a feladatok rendszerint kézzel is könnyedén
elvégezhetők, de a rendszer által biztosított parancsokkal általánosságában
könnyen tudjuk a projektet konfigurálni.

\medskip

A buildfolyamatot a Bitbake indításával kezdhetjük el. A program kapcsolók nélkül
indítva átvesz egy argumentumot, amely a végrehajtandó recept, majd a recept
alapján végrehajtja a szükséges feladatokat. A receptet a bitbake kiterjesztés
nélkül várja! A Bitbake-et egy recept végrehajtásához a következő módon
indíthatjuk el:

\begin{verbatim}
    $ bitbake <recept>
\end{verbatim}

A Bitbake a parancs hatására kezdeti lépésben beolvassa a \verb|bblayers.conf| és
\verb|local.conf| fileokat, majd az ezekben meghatározott módon beolvassa az
recepteket. A cél receptből kiindulva, a receptek tartalmazta feladatokból
függőségi fát épít, majd nekilát a feladatok végrehajtásának.

A build tesztelésére, esetlges konfigurációkra több kapcsolóval befolyásolhatjuk,
amelyek a bitbake felhasználása során nagy segítséget jelenthetnek, a teljesség
igénye nélkül néhány:

\begin{itemize}
\item{\verb|-e|:~A build során alkalmazott változókat listázza}
\item{\verb|-k|:~A build esetleges failelése esetén nem áll le, hanem minden
  feladatot végrehajt, amely nem függ a hibába futó feladattól}
\item{\verb|-c|:~A build során csak egy meghatározott feladatot hajt végre}
\end{itemize}

\section{Saját Linux image készítése}

A robot következő modulja a beágyazott Linux image, ennek elkészítéséhez a Yocto
Projectet használtam. Ebben a szegmensben a fejlesztés menetét fogom bemutatni.

\subsection{Specifikáció}

A Linux rendszer elkészítéséhez első lépésben specifikáltam az igényeket,
amelyeket ki kellett elégítenie az image-nek. Az igények felmérését követően
lehetséges megoldásokat kerestem, amelyeket kipróbáltam és teszteltem. A Linux
platform a robot esetében host platformként viselkedik, amely a ROS keretrendszer
futtatását végzi. A rendszernek azonban meg kell felelnie egyéb igényeknek is.

\subsubsection{Kapcsolat}

A rendszer vezeték nélkül vezérelhető legyen. Egy autonóm alkalmazásban a
legpraktikusabb megközelítés, ha a kommunikáció vezeték nélkül történik, a
robotban használt Raspberry Pi ehhez hardveres támogatást is biztosít. A
legideálisabb helyzetben a kapcsolat a fejlesztőeszközön és a roboton kívül nem
igényel egyéb támogatást, így ezt opcionális célnak tűztem ki.

\subsubsection{Soros port}

A rendszernek kommunikálnia kell tudni a vezérlőpanellel soros porton keresztül.
A kommunikációs csatorna kritikus, hiszen a ROS számára feltétlen szükséges, hogy
a hardverhez hozzáférjen, az ehhez defíniált protokol pedi USART kommunikációt
igényel.

\subsubsection{ROS}

A rendszernek futtatnia kell a ROS2 keretrendszert. A ROS2 rendszer
futtatása a legfontosabb feladat amely a linux rendszerre hárul. A
keretrendszeren kívül a saját ROS projektek futtatása szintén feladat, amelyek a
robot hardvert integrálják a ROS2 rendszerbe, valamint a magas szintű
funkcionalitást implementálják. A node-ok automatikus indítását nem tűztem ki
feladatul, mert úgy számoltam, hogy a rendszer idő hiányában nem fogja elérni a
teljes autonóm mozgást, így a ROS node-ok automatikus indítása kevésbé fontos
kritérium, valamint a parancssorból történő indítás implementációja után az
automatikus indítás egy triviális feladattá egyszerűsödik.

\subsubsection{Egyéb}

A könnyű feladatvégzés és tesztelés érdekében a rendszerbe egyéb packageket
telepítettem, mint szövegszerkesztő, file manager. Ezek a rendszernek nem
közvetlen részei, de meglétükkel a tesztelés és a rendszer használata sokkal
ergonómikusabb. 

\subsubsection{Build}

A buildel szembeni egyedüli igény, hogy minden fentebb specifikált funkciót és
konfigurációt generáljon bele az elkészített rendszer rootfilesystem-jébe. Így a
legkevesebb utómunka szükséges a deploymenthez, és a legjobban használató ki a
Yocto Project.

\subsection{Projekt layer: meta-rpirobot}

A feladat végrehajtását egy saját layer defíniálásával kezdtem, amelybe az image
generálásához szükséges receptek és fileok kerülnek. A layer alkalmas a munkám
verziókövetésére, valamint későbbi reprodukálására is. A fileok rendszerezése az
általános konvenciók szerinti felépítést követi. A layer tartalmaz egy conf
mappát, amelyben a layer.conf a layer beállításait tartalmazza.

A build szempontjából a legcélravezetőbbnek tartottam a Yocto Project legújabb
LTS kiadását, a kirkstone verzót használni. Ebből kifolyólag a saját layerem is a
kirkstone verzióval kompatibilis.

\subsubsection{Layerkonfiguráció}

A konfigurációban a layer tulajdonságait állíthatjuk be. Konfigurálható a
szükséges layerek listája, amik a layer függőségeiként szolgálnak, a kompatibilis
Yocto kiadás, valamint a receptek elrendezésének módja, ami alapján a bitbake
megtalálja a recepteket.

A layer függőségeit az alapvető layereken felül a meta-ros, meta-raspberrypi
és a meta-ros2-humble rétegekkel egészítettem ki.

A receptek és fileok megtalálásához konvenció szerinti alapértelmezett
beállításokat használtam. Ezek értelmében a recepteket a generált package nevével
ellátott mappa tartalmazza, amely mappákat általánosabb kategóriájuk szerint
recept-könyvtárakban tároljuk, az alábbi módon:

\dirtree{%
  .1 meta-rpirobot.
  .2 conf.
  .3 layer.conf.
  .2 LICENSE.MIT.
  .2 recipes-core.
  .3 busybox.
  .4 busybox.
  .5 udhcpd.conf.
  .4 busybox\_1.35.0.bbappend.
  .3 hostapd.
  .4 hostapd\_2.10.bbappend.
  .4 patch.
  .5 hostapd.conf.patch.
  .3 images.
  .4 rpirobot-core-image.bb.
  .3 init-ifupdown.
  .4 patch.
  .5 init-ifupdown\_1.0.bbappend.
  .3 ros-components.
  .4 files.
  .5 LICENSE.
  .4 ros-rpirobot-driver\_0.1.bb.
  .4 ros-rpirobot-interfaces\_0.1.bb.
  .3 wpa-supplicant.
  .4 wpa-supplicant.
  .5 wpa\_supplicant.conf-sane.patch.
}

Az ábrán látható, hogy a recipes-core mappában találhatóak a szükséges package-k
mappái, amelyeken belül a receptek és appendfileok találhatóak. 

\subsection{Az első boot}

A kész image előállítását egy Raspberry Pi-n bootolni képes image előállításával
kezdtem. A teljes image generálása komplex feladat, ennek megkönnyítésére a Yocto
Projectben egy \verb|core-image-minimal| recept is szerepel, amely leírása
alapján egy minimális Linux rendszer amely képes bootolni a target platformon. A
projektet tehát ennek az image-nek a generálásával kezdtem. A buildhez a
\verb|build/conf/bblayers.conf| fileban ki kellett egészíteni a layerlistát, a
Raspberry Pi támogatását biztosító meta-raspberrypi layerrel. Ezt követően a
\verb|build/conf/local.conf| fileban a machine változónak a ``raspberrypi4\-64''
értéket adva beállítottam a target platformot. Ezek után a core-image-minimal
targetet a Bitbake meghívásával előállítottam, majd bmaptools segítségével SD
kártyára másoltam az elkészült imaget. A bootolás tesztelvén a Raspberry Pi-hez
egy USB-USART átalalkító áramkörrek kapcsolódtam, majd megkíséreltem a bootolást,
amely sikeres volt.

\subsection{Image}

Az image generálást szintén receptek végzik, így a \verb|meta-rpirobot| layerben
a \verb|recipes-core/images| mappában létrehoztam egy receptet, ahol az image
elkészítéséhez szükséges feladatokat és konfigurációkat állíthatom be, ennek a
receptnek az \verb|rpirobot-core-image| nevet adtam.

A Bitbake támogatja a receptek további kiegészítését, ezért a legkézenfekvőbb
megoldás, a \verb|core-image-minimal| ``öröklése'' volt, ezt az inherit
kulcsszóval lehet megtenni.

A konfiguráció teszteléséhez licensz és summary beállításokat végeztem, majd az
image-et az említett hasznos eszközöket tartalmazó packagekkel egészítettem
ki. Ezek előnye hogy a Yocto alapértelmezett layereiben megtalálható a receptjük,
telepítésük pedig egyszerű, és minimális a hibalehetőség. Ezért a build
tesztelésére, és később az image-en való munka során is hasznos csomagok.

A telepített csomagok a vim, mc, bash, tmux, és a screen csomagok voltak. Egy
sikeres build lefuttatása után tapasztaltam, hogy az image az elvárt módon
tartalmazza ezeket a programokat. 

\medskip

A receptben az image kiegészítéséhez létezik egy alternatív mód, amely néhány
funkció esetében nagyban megkönnyíti a konfigurálást. Ez a funkció az image
feature amely lényegében teljes csomag- és konfigurációhalmazt jelent, amely az
image számára valamilyen teljes feature-t biztosít. A funkció az
\verb|IMAGE_FEATURES| változóhoz való hozzáfűzéssel érhető el, például a
következő képpen:

\begin{verbatim}
    IMAGE_FEATURES += "package-management"
\end{verbatim}

A fenti kóddal package managert, és a package managementhez szükséges egyéb
eszközöket telepítettem az image-re.

\subsection{A kapcsolat}

Az image fontos feladata, hogy vezeték nélküli kapcsolaton keresztül legyen
elérhető, ennek legkézenfekvőbb megoldását a beépített WiFi modul
felhasználásában láttam.

A kapcsolat kiépítésére WiFin keresztül két módon van lehetőség. Az egyik mód a
WiFi modult access point módban konfigurálni, amelyben a Raspberry Pi saját
hálózatot nyit, amelyhez bármilyen WiFi-képes eszközzel csatlakzhatunk. Az
autentikációra egy alapértelmezett és egyszerű jelszó generálható, amelyet az
első bejelentkezés után a felhasználó szabadon megváltoztathat. Ez a kialakítás
nagyon előnyös, mert nem igényel semmilyen külső eszközt, csak a fejlesztői
számítógépet valamint a robotot.

Alternatív megvalósításként a robot csatlakozhat egy előre bekonfigurált WiFi
hálózatra, amelyen innentől kezdve elérhető. Ez a megvalósítás sokkal egyszerűbb,
mint az access point kiépítése, ellenben a robot vezérléséhez valamilyen külső
eszköz és infrastruktúra megléte szükségeltetik, amelyet ráadásul a robot
konfigurációjának megfelelően kell beállítani. A megoldás további hátránya, hogy
a robotot helyhez köti, bár ez az állapot a robot feladatköréből adódóan nem
biztos, hogy tényleg problémát jelent, valamint könnyen orvosolható is, ha a
helyzet azt kívánja. 

\medskip

Első nekifutásra az access point konfigurációval próbálkoztam, a fent ismertetett
előnyei miatt. A konfigurációhoz hozzáadtam a hostapd csomagot, valamint a
\verb|busybox-udhcpd| csomagját. A hostapd az access point létrehozásáért és
üzemeltetéséért felelős szoftver, a \verb|busybox-udhcpd| pedig a busybox csomag
által szolgáltatott lightweight dhcp szerver, amely csatlakozó eszközök számára
szolgáltat ipcím kiosztást. A csomagok telepítése mellett appendfileokat hoztam
létre, amelyek a konfigurációt módosították a kívánt módon.

Több sikertelen tesztelési fázis, és hibakeresés után sikerült olyan
konfigurációt beállítanom, amelyben a robot saját hálózatát felállította, és a
csatlakozó eszközök számára ipcímet is szolgáltatott.

A kialakítás sajnálatos módon rendkívül instabil volt, gyakran fordult elő, hogy
a kapcsolat rövid időre megszakadt, amely használhatatlanná tette a megoldást. A
hibát minden valószínűség szerint a WiFi chip teljesítményének, vagy az
alkalmazott on-board antenna kialakításának nem megfelelősége okozta. A probléma
javítására külön WiFi eszköz beépítése egy praktikus megoldás, ilyen külső eszköz
amelyet USB-n keresztül lehet csatlakoztatni, könnyen be is szerezhető. A
fejlesztési idő miatt azonban tovább kellett lépnem és alternatív konfigurációt
kellett fejlesztenem.

\medskip

A végleges megoldásban a robot egy előre meglévő hálózathoz automatikusan
csatlakozik, ameyet a wpa-supplicant csomag konfigurációjával értem el. A külső
hálózatot egy telefonon indított hotspot hálózat biztosította. A hátrányokkal
együtt ez a kialakítás már sokkal stabilabban működött, így lehetőség volt tovább
lépni.

\medskip

\subsection{A layer index}

A felhasznált csomagok megtalálásában a leghasznosabb eszköz az
openembedded layer index volt. Ez az openembedded által jóváhagyott rétegeket
gyűjtő adatbázis, amelyhez egy webes frontend is tartozik. A weboldalon alkalmunk
nyílik layereket, és recepteket keresni, amelyekről az adatbázisból hasznos
információkat tudhatunk meg.

\todo{forrás}
A hálózati konfiguráció, valamint a telepített csomagok a meta-openembedded
layerben a meta-networking és a meta-oe alrétegekben voltak megtalálhatóak,
amelyeket ezért a layerlistához kellett adnom.

\subsection{Az USART port}

A soros kommunikáció a robottal kritikus feladat volt a ROS komponensek
telepítése és tesztelése előtt, lévén a saját komponensek a robot többi részével
UART interfészen keresztül tartják a kapcsolatot. Az USART port konfigurálását a
Raspberry Pi esetében azonban a bootfile-ok módosítását igényli.

A Raspberry Pi pinsorán kivezetet USART-on megjelenik egy konzol, amelyre
csatlakozva lehetőségünk nyílik az eszköz vezérlésére, egy teletype-on
keresztül. Ez a megoldás hasznos, ugyanis az eszközhöz kapcsolódhatunk akkor is
ha a hálózat meghibásodik, vagy egyéb okokból nem elérhető, ugyanakkor ennek a
portnak a felhasználásával könnyen csatlakoztatható a robot vezérlőpanelje is.  A
teletypeok menedzseléséért felelős service Linux rendszer alatt a \verb|getty|,
ennek konfigurációját azonban script állítja elő a build során, így
praktikusabbnak láttam a konfigurációt létrehozó scriptet befolyásoló változók
konfigurálását a végső script patchelésénél.

Az usart porton két jelenség történik, amelyet a port használatához el kell
kerülni. Az első,hogy a bootolás során a kernel üzenetei ezen a porton keresztül
jelennek meg, a másik, hogy a bootolást követően ezen a porton egy shellhez
csatlakoztatott teletype jelenik meg, amely ellehetetleníti a kommunikációt.

A fenti működéseket kikapcsolni a local.conf konfigurációba írt három sorral
lehet:

\begin{verbatim}
    ENABLE_UART = "1"
    SERIAL_CONSOLES = ""
    CMDLINE_SERIAL = ""
\end{verbatim}

Az első sor a build során inicializálja az USART-ot amelyen ezek után
kommunikálni lehet, majd a második és harmadik sor kikapcsolja az usarton
megjelenő parancssori interfészt, és kernelüzeneteket, így a port teljesen
szabadon marad a szükséges célra.

Fontos, hogy változók beállítása hatástalan, amennyiben azt az image-et generáló
receptben hajtjuk végre, ellenben a local.conf-ban történő beállítás sikerre
vezet. 

\subsection{A ROS keretrendszer}

A ROS2 keretrendszer integrálására a projekt hivatalos layerét használtam. A
layer a projekt fejlesztésével párhuzamosan fejlődött, így több frissítésre is
volt szükség mire a build sikeresen lezajlott.

A \verb|meta-ros| layer az openembedded kialakítás szerint egy repositoryban több
layert tárol, így a \verb|meta-ros| klónozása után a \verb|bblayers.conf| filet
több layerrel is kiegészítettem, ezek a \verb|meta-ros2|,
\verb|meta-ros2-humble|, \verb|meta-ros-common|. A ROS erőteljesen épít a Python
nyelvre, így függőségeinek kielégítéséhez a \verb|meta-openembedded| layer,
\verb|meta-python| sublayerét is felhasználtam.

A layerek kiegészítése után, a ROS telepítési útmutatóját követve az image
receptben meghatároztam a használni kívánt ROS disztribúciót, inicializáltam az
útmutató szerint a buildhez szükséges változókat, majd az ``IMAGE\_INSTALL''
változót bővítettem a ros-core, ros-base csomagokkal, valamint néhány example
kategóriájú csomaggal, amelyek a disztribúció tesztelésében nyújtottak
segítséget.

A build végül sikeresen lefutott, és az image flashelése után a Raspberry Pi-n
képes voltam a ROS beépített példamoduljait futtatni. 

\subsection{A saját ROS packagek}

A ROS projekt önmagában egy keretrendszer, a robot működéséhez a buildnek
automatikusan tartalmaznia kell a robothoz készült ROS packageket is. Ezeknek a
packageknek a fordításához a meta-ros layer többi receptjét vettem alapul,
valamint a ROS2 fórumokon más olyan projekteket, amelyek saját recept
lefordításán alapultak.\todo{source?}

A projekt során elkészített ROS package-ekről a következő fejezetben részletesen
lesz szó, a jelenlegi fejezetben csak lefordításuk és buildrendszerbe történő
integrálásukat tárgyalom.

A projekthez két ROS package készült el, amelyekhez a fordítást a ROS az ament
buildrendszer segítségével végezi el, amely CMake és Python alapú packagek
létrehozására szolgáló rendszer. A meta-ros layer az ament felhasználására
biztosít lehetőségeket, így a package-k integrálása kisebb erőfeszítések árán
megoldható: 


\begin{verbatim}
asdfsadfasfdas
\end{verbatim}
\todo{ide a fontos parancsot beírni, a csomagkészítéshez}

A két package közül egy \verb|ament_cmake|, egy pedig \verb|ament_python|
buildrendszert használ, ezekhez külön scriptek készültek a
\verb|recipes-core/ros-components| mappában.

A receptek felépítése mindkét esetben rendkívül hasonló. Elsősorban a recepthez
tartozó weboldalt, maintainert, valamint rövid leírást kell kitölteni, amit a
licensz file, és hozzá tartozó checksum követ.

A ros külön változókba gyűjti a fordításidejű és futásidejű függőségeket, ezek
megadása a következő feladat. 

A Yocto rendszerben minden forrás valamilyen upstreamről kerül letöltésre, a
packagek esetében ez a github repository, amelyen tároltam őket. Ennek az
upstreamnek a megadása a következő lépés, amely során nem csak az upstreamhez
tartozó URL-t, hanem a branch, és githash értékeit is meg kell adni a pontos
verzió letöltéséhez. 

\todo{valami formát találni a kódsoroknak}
A packagek fordításához tartozó feladatokat az inherit ros\_ament\_cmake, vagy
inherit \verb|ros_ament_python| sorokkal csatolhatjuk a recepthez, ami a továbbiakban
már tudni fogja hogy milyen lépéseket kell végrehajtani a ROS package
lefordításához.

Utolsó lépésben a csomaghoz tartozó \verb|FILES| változó értékét kell beállítani
olymódon, hogy kiegészítjük, minden csomagba telepítendő fileal, ami a receptek
esetén a következő sorral volt kivitelezhető:

\begin{verbatim}
    FILES:${PN} += "/usr/share/<csomagnév>/*"
\end{verbatim}

\subsection{Fejlesztési lehetőségek}

A build végeredményében egy sikeres és használható disztribúciót állít elő,
amelynek konfigurációját teljesen automatikusan végzi el. A saját réteg
alkalmazásának megfelelően a reprodukció könnyen és gyorsan végrehajtható, hiszen
ahhoz csak a layerek klónozására van szükség, amelyeket a kirkstone branchre
állítva a lokális konfiguráció kiegészítésével már indíthatjuk is a build
folyamatot. 

A rendszer ugyanakkor több fejlesztési lehetőséget is tartalmaz. A fejlesztés
során a hálózathoz csatlakozás mellett döntöttem a fejleszés sebessége és az
időkeret miatt. Egy új WiFi modul csatlakoztatásával és integrálásával az
instabilitás orvosolható lehet, és a robottal való kommunikáció egy elegánsabb
módon valósítható meg. 

A Raspberry Pi több USART portal is rendelkezik, az egyszerűség kedvéért a
projekt során a legkönnyebben elérhetőt választottam. A soros port meghagyása
azonban debuggolás szempontjából hasznos biztonsági tartalék. A konfiguráció
tovább fejleszthető olyan módon, hogy egy másik port kivezetésével az eredeti
megőrizhető erre a célra.

A ROS projekt ugyan integrálva van a buildben, ellendben automatikus indítása nem
megoldott. A rendszer egy setup script source-olását igényli, amely a
futtatókörnyezetet állítja be a ros számára. A rendszerben használt shell, a bash
inicializációs fileját kiegészítve ez a sourceolás automatikusan elvégezhető
volna.

A projekt szempontjából ésszerű lenne a buildben egy scriptet mellékelni, amely
segítségével a ROS2 packagekben megvalósított a saját funkcionalitás
indítható. Ez a script az init program által is végrehajtható, így az automatikus
indítás megvalósítható.

